[manpage_begin yajl-tcl n 1.0]
[moddesc   {Tcl bindings for Yet Another JSON Library (YAJL)}]
[copyright {2010 FlightAware LLC (BSD Liscense)}]
[titledesc {Tcl application launcher}]
[description]
[para]

Yajl-tcl is a Tcl C extension written to make the Yet Another JSON Library
(YAJL).  JSON stands for Javascript Object Notation, a popular data 
exchange format for Javascript.

[para]

Although there is already a package in the tcllib library, huddle, that
can generate JSON, the big advantage in using yajl-tcl is performance.

[para]

In a benchmark generating 5,000 airport codes, altitudes and longitudes in
JSON, in a format used by openlayers, yajl-tcl was 157 times faster.
(21 milliseconds versus 3.3 seconds on a Xeon processor.)

THAT'S IT SO FAR

[para]

Well, OK, but this has certain problems:
[list_begin item]
[item] All your Tcl programs will show in "ps" as tclsh
[item] All your Tcl programs will show in "top" as tclsh
[item] if there are any files you want to pull in that aren't in a package,
you have to invent your own place to install and locate them.
[list_end]

[para]

You'd like to be able to have stuff show up as its script name.

[para]

You could just copy or even link tclsh to the name of your program.
Say, for instance, trackserver.

[para]

But then you have to invoke trackserver with arguments and do stuff to
prep it, like:

[example_begin]
    cd ...somewhere...
    /usr/local/bin/trackserver main.tcl
[example_end]

That's the original purpose for tcllauncher, just to make that reasonable.

[example_begin]
    cp /usr/local/bin/tcllauncher /usr/local/bin/trackserver

    trackserver
[example_end]

How does it find its files?  It cd's to the corresponding lib directory and
a directory underneath that of the same name as the application, and sources
[file main.tcl] with [var tcl_interactive] set to 0.

[para]

So when [file tcllauncher] is installed as [file trackserver] and you run trackserver, what happens [file /usr/local/bin/trackserver] starts up like the
Tcl shell, except that it sources in [file /usr/local/lib/trackserver/main.tcl].

Also, a global variable called [var launchdir] is set containing the "launch
directory," i.e. the directory where main.tcl was loaded from.  
( In the above example, [file /usr/local/lib/trackserver.])

[section {WHAT DIRECTORY}]

Tcllauncher doesn't change your directory behind your back, so wherever you
are at when you run it, you're still in that directory.

[para]

But a lot of times you want to go to your application directory, so you
can just 

[example_begin]
	cd $::launchdir
[example_end]

Then you can source in all of your various files and stuff like that.

[section {PROCESS GROUP}]

If you are going to fork off children, exec them, or whatever, you should
probably become your own process group so hopefully your children might
inherit your signals and Do The Right Thing.

[example_begin]
    id process group set
[example_end]

The [cmd id] command is from the TclX extension.

[section {PID FILE}]

Lots of apps write a file with the server's process ID in it.  Upon relaunch,
the program can come along and look in its own pid file to see if it's already
alive or not, and also to potentially kill it.

[para]

Our pidfile support is a studied Tcl-based copy of BSD's pidfile C library.

[para]

[list_begin definitions]
[call [cmd ::tcllauncher::pidfile_open] \
        [opt "[arg path]"] \
        [opt "[arg mode]"]]

Given an optional path to a directory and optional permissions, 
pidfile_open opens (or creates) a file specified by the path
and locks it with TclX's interface to the [cmd flock] system call.

[para]

If the file cannot be locked, the PID of an already running daemon is
returned.

Otherwise zero is returned and you've got the lock. You can now call 
[cmd pidfile_write] to get your pid into the lock file.

[para]

This function does not write your process' PID into the file,
so it can be used before forking if needed.

[para]
If path is not specified, [file /var/run] is psed, and if mode is not
specified, 0600 is used.

[call [cmd ::tcllauncher::pidfile_write]]

Writes your pid into the pid file previously opened by [cmd pidfile_open].

[call [cmd ::tcllauncher::pidfile_close ]]

Close a pidfile.  It should be used after your daemon forks to start
a child process.

[call [cmd ::tcllauncher::pidfile_remove]]

Close and remove a pidfile.

[list_end]
[section {EXAMPLE}]

[example_begin]
    set pid [lb]::tcllauncher::pidfile_open "/var/run/daemon.pid 0600[rb]
    if {$pid > 0} {
	puts stderr "pid $pid already has the lock"
	exit 1
    }

    ::tcllauncher::daemonize

    ::tcllauncher::pidfile_write

    ...do work...

    ::tcllauncher::pidfile_remove
    exit
[example_end]

[section {DAEMONIZE}]

Sometimes you want your program to spawn itself off into the background in
a way that when you logout it doesn't kill the process, etc.

To daemonize a tcllauncher app,

[list_begin definitions]
[call [cmd ::tcllauncher::daemonize] \
        [opt "[arg -noclose]"] \
        [opt "[arg -nochdir]"]]

By default this forks off a child and exits the parent.  In the child, it
changes the current directory to [file /], and redirects stdin, stdout and 
stderr to/from [file /dev/null].

[para]
Specifying [arg -noclose] prevents the closing and redirecting of stdin,
stdout and stderr, while [arg -nochdir] prevents the changing of the working
dir to [file /]

[para]
This is a rough copy of BSD 4.4's [cmd daemon] library routine.
[list_end]

[section {USER AND GROUP ID MANAGEMENT}]

If a program needs to be run as a certain use, it can invoke

[list_begin definitions]
[call [cmd ::tcllauncher::require_user] \
    [arg userName]]

This requires the program to either be run as fred or as root or something
like that, by a user that has permissions to become fred.

[para]

If the program is running as user fred or can change the user id (suid) to
fred, it continues, else it aborts.

[para]

This means if the superuser invokes the program, it will change user to the correct user.  If the correct user invokes the program, it will correctly do nothing and proceed.  Handy.

[call [cmd ::tcllauncher::require_group] \
    [arg groupName]] does for groups what require_user does for
users.

[call [cmd ::tcllauncher::require_user_and_group] \
    [arg userName] \
    [arg groupName]] 
combines changing the group and user into a single procedure.

[list_end]
[para]

Note that if you require user first then require group, the process may have
lost the privileges necessary to change groups after changing users.  Either
require the group ID first or use [cmd ::tcllauncher::require_user_and_group]
to do both.

[keywords tcllauncher daemon daemonize background]
[manpage_end]
